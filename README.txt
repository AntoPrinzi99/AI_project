
Sliding Puzzle â€” A* and CSP (Z3)
===============================

This folder contains two different AI techniques to solve the same problem: the generalized sliding-tile puzzle (NxN).

- `implementation_A.py`: A* search with **duplicate elimination** and **no reopening**.
- `CSP.py`: reduction to **CSP** and solution via **Z3** (SMT solver), using **iterative deepening on the horizon**.


Requirements
------------

- Python 3
- For `CSP.py` only: the external dependency `z3-solver`
	- Install with: `python3 -m pip install z3-solver`

Important:
- `CSP.py` imports helper functions from `implementation_A.py`, so both files must stay in the **same directory**.


Install dependencies (CSP/Z3)
-----------------------------

A* (`implementation_A.py`) uses only the Python standard library.

For CSP/Z3 (`CSP.py`), install Z3 for Python.

Important: the package must be installed into the SAME Python interpreter you use to run the script.

If you run with system Python:

	python3 -m pip install z3-solver

If you run with a virtual environment (recommended):

	python3 -m venv .venv
	. .venv/bin/activate
	python -m pip install z3-solver
	python CSP.py --help

Note (Linux / Ubuntu / Debian): if you see `error: externally-managed-environment`, your system Python blocks global pip installs.
Use the virtual environment commands above (no sudo needed).


Puzzle representation
---------------------

When passing an initial state with `--initial`, the state is given as `N*N` integers in **row-major order** (row by row).

- Tiles are `0 .. N^2-1`
- `0` is the **blank** (empty cell)

Example for 3x3:

	--initial 1 2 3 4 5 6 7 0 8


How to run A* (implementation_A.py)
---------------------------

Show help:

	python3 implementation_A.py --help



Run experiments with multiple runs (if `--runs > 1`, a new random instance is generated each run):

	python3 implementation_A.py --size 4 --random-moves 30 --runs 10 --seed 1 --heuristic misplaced
	python3 implementation_A.py --size 4 --random-moves 30 --runs 10 --seed 1 --heuristic manhattan

Change `--size 4` to `--size 5` for 5x5 problems.

---

Other possibilities (implemented but not used in the reported experiments)

Run a single instance generated by scrambling the goal with K legal moves (guaranteed solvable):

	python3 implementation_A.py --size 4 --random-moves 30 --seed 0 --heuristic manhattan

Run a custom instance (validated as a permutation and checked for solvability):

	python3 implementation_A.py --size 4 --initial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 15 --heuristic manhattan

Print boards (useful for debugging; noisy for experiments):

	python3 implementation_A.py --size 4 --random-moves 30 --seed 1 --show-boards


A* output / metrics
-------------------

`implementation_A.py` prints, for each run:

- `Solution found: cost=... moves=...` (moves are a string over U/D/L/R)
- `expanded`: number of expanded nodes
- `generated`: number of generated nodes
- `max_frontier`, `max_explored`: peak sizes
- `frontier_final`, `explored_final`: final sizes
- `elapsed_sec`: runtime

If `--runs > 1`, it also prints a final summary with mean values.


How to run CSP/Z3 (CSP.py)
----------------------------

Show help:

	python3 CSP.py --help

Generate a solvable instance by scrambling the goal and solve it with Z3:

	python3 CSP.py --size 4 --random-moves 30 --seed 1 --max-steps 40

This is the command used for the CSP/Z3 experiment reported in the write-up (single run). A 10-run average is typically impractical here because CSP/Z3 can take minutes even for one non-trivial 4x4 instance at this scramble depth.

---

Other possibilities (implemented but not used in the reported experiments)

Run experiments with multiple runs (a new scrambled instance is generated each run by using `seed + run_index`):

	python3 CSP.py --size 4 --runs 10 --random-moves 30 --seed 1 --max-steps 40 --progress

Solve a custom instance:

	python3 CSP.py --size 4 --initial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 0 15 --max-steps 10

Print boards:

	python3 CSP.py --size 5 --random-moves 30 --seed 1 --max-steps 40 --show-boards


CSP/Z3 notes (important)
------------------------

- `CSP.py` is intended for `--size 4` or `--size 5`.
- The CSP is solved by iterative deepening on the horizon T:
  it tries T = 0, 1, 2, ... up to `--max-steps`.
  The first satisfiable T gives the shortest plan within that limit.
- Runtime can grow quickly as `--max-steps` increases, because the number of variables/constraints grows with T.
- Use `--progress` to print which horizon T is being attempted (useful when a run takes minutes).


CSP/Z3 output / metrics
-----------------------

`CSP.py` prints:

- `Solution found (CSP/Z3): cost=... moves=...`
- `horizon=... solver_calls=... horizons_tried=... elapsed_sec=...`

If `--runs > 1`, it also prints a final summary with mean values.

The most relevant measures are plan length (cost/horizon) and total solver time.
Additionally:
- `solver_calls` / `horizons_tried` indicate how many horizons T were checked (T=0..horizon). This is useful to explain why CSP can be slower than A*: it may solve several UNSAT horizons before reaching the first SAT horizon.


Troubleshooting
---------------

- Error: "Missing dependency 'z3-solver'"
  - Fix: `python3 -m pip install z3-solver`

- Error: `error: externally-managed-environment`
	- Meaning: your OS prevents installing Python packages into the system interpreter.
	- Fix (recommended):
		- `python3 -m venv .venv`
		- `. .venv/bin/activate`
		- `python -m pip install z3-solver`
		- `python CSP.py --help`

- Error: "Unsolvable instance for this goal (parity mismatch)."
  - Meaning: the given permutation is not reachable from the goal.
  - Fix: use `--random-moves ...` or provide a solvable `--initial`.

